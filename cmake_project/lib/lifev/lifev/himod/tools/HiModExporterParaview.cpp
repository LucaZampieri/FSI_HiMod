#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#include <lifev/himod/tools/HiModExporterParaview.hpp>

namespace LifeV
{

HiModExporterParaview::
HiModExporterParaview( std::string fileName,
                       const NSModalSpaceCircular& MB,
                       const Real& h, 
                       const UInt& Nelements,
                       const UInt& Ntimesteps, const Real& dt ) :
                       M_uMeshSize( h ), M_Nelements( Nelements ),
                       M_R( MB.Rho() ),
                       M_quadrulerho( MB.qrRho() ),
                       M_quadruletheta( MB.qrTheta() )
{
    const UInt udof( 2 * Nelements + 1 );
	const UInt pdof( Nelements + 1 );
	
	const UInt nquadRho( M_quadrulerho->nbQuadPt() );
	const UInt nquadTheta( M_quadruletheta->nbQuadPt() );
	
	Real Theta( 2 * M_PI );

	std::string filenameCase( fileName+".case" );
	std::string filenameGeo( fileName+".geo" );
    
//    std::string filenamePress( fileName );
//    filenamePress += "_pressure.";
	
    // ______________________    geo    _____________________________
    std::ofstream geo( filenameGeo.c_str(), std::ofstream::out );
    
    UInt npoints( udof * nquadRho * nquadTheta );
    std::stringstream Npoints;
	Npoints << npoints;
	
	UInt digitNpoints( static_cast<UInt>( log10( (double) npoints ) ) + 1 );
	
	// Compute x y z
    matrix_pointType points;
    points.resize( npoints, vector_Type( 3, 0. ) );
    
    for( UInt ix( 0 ); ix != udof; ++ix )
	{     
		for( UInt itheta( 0 ); itheta != nquadTheta; ++itheta )
		{  
			for( UInt irho( 0 ); irho != nquadRho; ++irho )
			{
			    UInt index( ix*nquadRho*nquadTheta + itheta*nquadTheta + irho  );
				points[index][0] = ix * M_uMeshSize;
				points[index][1] = M_quadrulerho->quadPointCoor( irho, 0 ) * M_R * cos( M_quadruletheta->quadPointCoor( itheta, 0 ) * Theta );
				points[index][2] = M_quadrulerho->quadPointCoor( irho, 0 ) * M_R * sin( M_quadruletheta->quadPointCoor( itheta, 0 ) * Theta );
			}
		}
	}
	
	// Write the points
    
    std::stringstream space;
    space.str("");
    
    for( UInt t( 0 ); t != 8 - digitNpoints; ++t )
    {
        space << " ";
    }
    
	geo << "Geometry file" << std::endl;
	geo << "Generated by LifeV" << std::endl;
	geo << "node id given" << std::endl;
	geo << "element id given" << std::endl;
	geo << "coordinates" << std::endl;
	geo << space.str() << Npoints.str() << std::endl;
    
    for( UInt s( 1 ); s != digitNpoints; ++s )
	{
		// set tabs
		std::stringstream tabs;
		tabs << "";
		
		for( UInt i( 0 ); i != digitNpoints - s; ++i )
		{
			tabs << " ";
		}
		
		std::stringstream x;
		std::stringstream y;
		std::stringstream z;
	
		for( UInt i( pow( 10, s - 1 ) - 1 ); i != pow( 10, s ) - 1; ++i )
		{
			UInt index( i );
		    geo << space.str() << tabs.str() << i + 1;
		
			if( points[index][0] >= 0 )
			{
				x << " ";
			}
			x.setf( std::ios_base::scientific, std::ios_base::floatfield );
			x.precision( 5 );
			x << points[index][0];
		
			if( points[index][1] >= 0 )
			{
				y << " ";
			}
			y.setf( std::ios_base::scientific, std::ios_base::floatfield );
			y.precision( 5 );
			y << points[index][1];
		
			if( points[index][2] >= 0 )
			{
				z << " ";
			}
			z.setf( std::ios_base::scientific, std::ios_base::floatfield );
			z.precision( 5 );
			z << points[index][2];
		
			geo << x.str() << y.str() << z.str() << std::endl;
		
			x.str("");
			y.str("");
			z.str("");
		}
		
		tabs.str("");
	}

	for( UInt i( pow( 10, digitNpoints - 1 ) - 1 ); i != points.size(); ++i )
	{
		std::stringstream x;
		std::stringstream y;
		std::stringstream z;
				
		    geo << space.str() << i + 1;

		    UInt index( i );
			if( points[index][0] >= 0 )
			{
				x << " ";
			}
			x.setf( std::ios_base::scientific, std::ios_base::floatfield );
			x.precision( 5 );
			x << points[index][0];

			if( points[index][1] >= 0 )
			{
				y << " ";
			}
			y.setf( std::ios_base::scientific, std::ios_base::floatfield );
			y.precision( 5 );
			y << points[index][1];

			if( points[index][2] >= 0 )
			{
				z << " ";
			}
			z.setf( std::ios_base::scientific, std::ios_base::floatfield );
			z.precision( 5 );
			z << points[index][2];

			geo << x.str() << y.str() << z.str() << std::endl;
		
			x.str("");
			y.str("");
			z.str("");
	}
    
    	// Tetra -----------------------------------------------------------------------
    UInt ntetra( ( udof - 1 ) * ( ( nquadRho - 1 ) * nquadTheta +
                 ( nquadTheta - 4 ) / 2 + 1 ) );
	std::stringstream Ntetra;
	Ntetra << ntetra;
	
	static matrix_tetraType tetrahedra;
    tetrahedra.resize( ntetra, vector_UInt_Type( 8, 0 ) );

    // Build tetra
    UInt tetInd( 0 );
    UInt shift( nquadRho * nquadTheta );	                        
    for( UInt s( 0 ); s != udof - 1; ++s )
    {
        // radial polygons
        for( UInt t( 0 ); t != nquadTheta - 1; ++t )
        {
            for( UInt n( 0 ); n != nquadRho - 1; ++n )
            {
                UInt i( s * shift + t * nquadRho + n );

                tetrahedra[tetInd][0] = i;
                tetrahedra[tetInd][1] = i + 1;
                tetrahedra[tetInd][2] = i + 1 + nquadRho;
                tetrahedra[tetInd][3] = i + nquadRho;
                tetrahedra[tetInd][4] = i + shift;
                tetrahedra[tetInd][5] = i + 1 + shift;
                tetrahedra[tetInd][6] = i + 1 + nquadRho + shift;
                tetrahedra[tetInd][7] = i + nquadRho + shift;

                ++tetInd;
                
            }
        }
            // restoration of periodicity
        for( UInt n( 0 ); n != nquadRho - 1; ++n )
        {
            UInt i( s * shift + ( nquadTheta - 1 ) * nquadRho + n );

            tetrahedra[tetInd][0] = i;
            tetrahedra[tetInd][1] = i + 1;
            tetrahedra[tetInd][2] =  n + 1 + s * shift;
            tetrahedra[tetInd][3] = n + s * shift;
            tetrahedra[tetInd][4] = i + shift;
            tetrahedra[tetInd][5] = i + 1 + shift;
            tetrahedra[tetInd][6] = n + 1 + shift + s * shift;
            tetrahedra[tetInd][7] = n + shift + s * shift;

            ++tetInd;
        }
    }
    
    // inner cylindrical core
    for( UInt s( 0 ); s != udof - 1; ++s )
    {
        for( UInt v( 0 ); v != ( nquadTheta - 4 ) / 2 + 1; ++v )
        {
            UInt i( s * shift );
            tetrahedra[tetInd][0] = i;
            tetrahedra[tetInd][1] = i + ( 2 * v + 1 ) * nquadRho;
            tetrahedra[tetInd][2] = i + ( 2 * v + 2 ) * nquadRho;
            tetrahedra[tetInd][3] = i + ( 2 * v + 3 ) * nquadRho;
            tetrahedra[tetInd][4] = i + shift;
            tetrahedra[tetInd][5] = i + ( 2 * v + 1 ) * nquadRho + shift;
            tetrahedra[tetInd][6] = i + ( 2 * v + 2 ) * nquadRho + shift;
            tetrahedra[tetInd][7] = i + ( 2 * v + 3 ) * nquadRho + shift;

            ++tetInd;
        }
    }
    // end build tetra
    
    // Write tetra
    UInt digitNtetra( static_cast<UInt>( log10( (double) ntetra ) ) + 1 );
	
	space.str("");
	for( UInt t( 0 ); t != 8 - digitNtetra; ++t )
    {
        space << " ";
    }
    
	geo << "part\t\t1" << std::endl;
	geo << "full geometry" << std::endl;
	geo << "HEX8" << std::endl;
	geo << space.str() << Ntetra.str() << std::endl;
	
	for( UInt s( 1 ); s != digitNtetra; ++s )
	{
		// set tabs
		std::stringstream tabs;
		tabs << "";
		
		for( UInt i( 0 ); i != digitNpoints - s; ++i )
		{
			tabs << " ";
		}
		
		for( UInt i( pow( 10, s - 1 ) - 1 ); i != pow( 10, s ) - 1; ++i )
		{
			UInt index( i );
		    geo << space.str() << tabs.str() << i + 1;
		    
		    // Print vertices of i-th tetra
		    for( UInt v( 0 ); v != 8; ++v )
		    {
		        std::stringstream coltabs;
        		coltabs.str("");
        		
		        for( UInt t( 0 ); t != 8 - (UInt)( log10( (double) tetrahedra[i][v] ) ) + 1; ++t )
		        {
		            coltabs << " ";
		        }
		        
		        geo << coltabs.str() << tetrahedra[i][v];
		    }
		    
		    geo << std::endl;
		}
	}
	
	for( UInt i( pow( 10, digitNtetra - 1 ) - 1 ); i != tetrahedra.size(); ++i )
	{
	    std::stringstream x;
        std::stringstream y;
		std::stringstream z;
				
		geo << space.str() << i + 1;

        // Print vertices of i-th tetra
		    for( UInt v( 0 ); v != 8; ++v )
		    {
		        std::stringstream coltabs;
        		coltabs.str("");
        		
		        for( UInt t( 0 ); t != 8 - (UInt)( log10( (double) tetrahedra[i][v] ) ) + 1; ++t )
		        {
		            coltabs << " ";
		        }
		        
		        geo << coltabs.str() << tetrahedra[i][v];
		    }
		    
		    geo << std::endl;

	}	
	
	geo.close();
    
    // ___________________ CASE __________________________________
    std::ofstream fileCase( filenameCase.c_str() );
    
	std::stringstream Tsteps;
	Tsteps << Ntimesteps + 1;
	
	fileCase << "FORMAT" << std::endl;
	fileCase << "type: ensight" << std::endl;

	fileCase << "GEOMETRY" << std::endl;
	fileCase << "model: 1 " << filenameGeo.c_str() << std::endl;

	fileCase << "VARIABLE" << std::endl;
	fileCase << "vector per node: 1 velocity " << fileName << "_velocity.***.vct" << std::endl;
//	filenameCase << "scalar per node: 1 pressure pressure.***.scl" << std::endl;
	
	fileCase << "TIME" << std::endl;
	fileCase << "time set: 1" << std::endl;
	fileCase << "number of steps: " << Tsteps.str() << std::endl;
	fileCase << "filename start number: 0" << std::endl;
	fileCase << "filename increment: 1" << std::endl;
	fileCase << "time values: " << std::endl;
	fileCase << "0 ";
	
	Tsteps.str("");
	for( UInt tIter( 0 ); tIter != Ntimesteps; ++tIter )
	{
	    Tsteps << ( tIter + 1 ) * dt;
	    fileCase << Tsteps.str() << " ";
	    Tsteps.str("");
	}
	
	fileCase.close();

}

void
HiModExporterParaview::
writeSolution( std::string fileName, const VectorEpetraStructured& solution_3D, const UInt& timeIter ) const
{
    std::string filenameVel( fileName+"_velocity." );

    const UInt udof( 2 * M_Nelements + 1 );
	const UInt pdof( M_Nelements + 1 );
	
	const UInt nquadRho( M_quadrulerho->nbQuadPt() );
	const UInt nquadTheta( M_quadruletheta->nbQuadPt() );
	
	Real Theta( 2 * M_PI );
	
    // Swap to cartesian coordinates
	VectorEpetraStructured gridCartesianSolution( solution_3D );
	for(  UInt ix = 0; ix!= udof; ++ix )
	{
    	for( UInt itheta( 0 ); itheta != nquadTheta; ++itheta )
		{  
			for( UInt irho( 0 ); irho != nquadRho; ++irho )
			{
			    UInt ny( ( ix + udof ) * nquadTheta * nquadRho +
			               itheta * nquadRho + irho );
			    UInt nz( ( ix + 2 * udof ) * nquadTheta * nquadRho +
			               itheta * nquadRho + irho );
	            Real theta( M_quadruletheta->quadPointCoor( itheta, 0 ) * Theta );    
	            
	            gridCartesianSolution[ny] = solution_3D[ny] * cos( theta ) -
	                                        solution_3D[nz] * sin( theta );
	            gridCartesianSolution[nz] = solution_3D[ny] * sin( theta ) +
	                                        solution_3D[nz] * cos( theta );
	        }
	    }
	}
   
    // ______________ vct ___________________
    std::stringstream fileIter;
    UInt nDigits( static_cast<UInt>( log10( (double) timeIter ) ) + 1 );

    if( nDigits > 3 )
    {
    	std::cout << "Error: too many time steps." <<std::endl;
    	return;
    }

    for( UInt s( 0 ); s != 3 - nDigits; ++s )
    {
        fileIter << "0";
    }
    fileIter << timeIter;

    filenameVel += fileIter.str();
    filenameVel += ".vct";

//    filenamePress += fileIter.str();
//    filenamePress += ".scl";

	std::ofstream velocity( filenameVel.c_str(), std::ofstream::out );    
    velocity << "Vector per node" << std::endl;
    
    std::stringstream vx;
    std::stringstream vy;
    std::stringstream vz;
		
for( UInt ix( 0 ); ix != udof; ++ix )
	{     
		for( UInt itheta( 0 ); itheta != nquadTheta; ++itheta ) 
		{  
			for( UInt irho( 0 ); irho != nquadRho; ++irho )		
            {
                UInt ivx( ix * nquadTheta * nquadRho + itheta * nquadRho + irho );
                UInt ivy( (udof + ix) * nquadTheta * nquadRho +
                           itheta * nquadRho + irho );
                UInt ivz( (2*udof + ix) * nquadTheta * nquadRho +
                           itheta * nquadRho + irho );
                
                if( gridCartesianSolution[ix] >= 0 )
                {
                    vx << " ";
                }
                else
                {
                    vx << "";
                }
                vx.setf( std::ios_base::scientific, std::ios_base::floatfield );
                vx.precision( 5 );
                if( gridCartesianSolution[ivx] < pow( 10, -99 ) &&
                    gridCartesianSolution[ivx] >= 0 )
                {
                    vx << 0.;
                }
                else if( gridCartesianSolution[ivx] > - pow( 10, -99 ) &&
                         gridCartesianSolution[ivx] <= 0 )
                {
                    vx << -0.;
                }
                else
                {
                    vx << gridCartesianSolution[ivx];
                }
               			
                if( gridCartesianSolution[ivy] >= 0 )
                {
                    vy << " ";
                }
                else
                {
                    vy << "";
                }
                vy.setf( std::ios_base::scientific, std::ios_base::floatfield );
                vy.precision( 5 );
                if( gridCartesianSolution[ivy] < pow( 10, -99 ) && 
                    gridCartesianSolution[ivy] >= 0 )
                {
                    vy << 0.;
                }
                else if( gridCartesianSolution[ivy] > - pow( 10, -99 ) && 
                         gridCartesianSolution[ivy] <= 0 )
                {
                    vy << -0.;
                }
                else
                {
                    vy << gridCartesianSolution[ivy];
                }
	            
	            // z component
                if( gridCartesianSolution[ivz] >= 0 )
                {
                    vz << " ";
                }
                else
                {
                    vz << "";
                }
                vz.setf( std::ios_base::scientific, std::ios_base::floatfield );
                vz.precision( 5 );
                if( gridCartesianSolution[ivz] < pow( 10, -99 ) &&
                    gridCartesianSolution[ivz] >= 0 )
                {
                    vz << 0.;
                }
                else if( gridCartesianSolution[ivz] > - pow( 10, -99 ) && 
                         gridCartesianSolution[ivz] <= 0 )
                {
                    vy << -0.;
                }
                else
                {
                    vz << gridCartesianSolution[ivz];
                }
	                    
                velocity << vx.str() << vy.str() << vz.str();
				
                if( remainder( ivx+1, 2 ) == 0 )
                {
                    velocity << std::endl;
                }
				
                vx.str("");
                vy.str("");
                vz.str("");
            }
        }
    }
	
    velocity.close();	
    
    // ___________________ TODO modify here on _______________
	
		

    // ______________________    pressure    _____________________________
    
/*    std::ofstream pressure( filenamePress.c_str(), std::ofstream::out );
    
    pressure << "# vtk DataFile Version 3.0" << std::endl;
    pressure << "LifeV output" << std::endl;
    pressure << "ASCII" << std::endl;
    pressure << "DATASET UNSTRUCTURED_GRID" << std::endl;
    pressure << "POINTS " << pdof * nquadRho * nquadTheta << " float" << std::endl;

    
    for( UInt ix( 0 ); ix != pdof; ++ix )
			{     
				for( UInt itheta( 0 ); itheta != nquadTheta; ++itheta )
				{  
					for( UInt irho( 0 ); irho != nquadRho; ++irho )
					{
						pressure <<
						ix * 2 * M_uMeshSize <<" "<<
						M_quadrulerho->quadPointCoor( irho, 0 ) * M_R * cos( M_quadruletheta->quadPointCoor( itheta, 0 ) * Theta ) << " "<<
						M_quadrulerho->quadPointCoor( irho, 0 ) * M_R * sin( M_quadruletheta->quadPointCoor( itheta, 0 ) * Theta ) << std::endl;
											
					}
				}
			}
    pressure << "CELLS " << ( pdof - 1 ) * ( ( nquadRho - 1 ) * nquadTheta + ( nquadTheta - 4 ) / 2 + 1 ) << " " 
	                        << ( ( nquadRho - 1 ) * nquadTheta + ( nquadTheta - 4 ) / 2 + 1 ) * 9 * ( pdof - 1 ) << std::endl;
	                        
    for( UInt s( 0 ); s != pdof - 1; ++s )
    {
        // radial polygons
        for( UInt h( 0 ); h != nquadTheta - 1; ++h )
        {
            for( UInt n( 0 ); n != nquadRho - 1; ++n )
            {
                UInt i( s * shift + h * nquadRho + n );

                pressure << 8 << " " << i << " " << i + 1 << " " << i + 1 + nquadRho << " " << i + nquadRho << " "
                                     << i + shift << " " << i + 1 + shift << " " << i + 1 + nquadRho + shift << " " << i + nquadRho + shift << std::endl;
            }
        }
            // restoration of periodicity
        for( UInt n( 0 ); n != nquadRho - 1; ++n )
        {
            UInt i( s * shift + ( nquadTheta - 1 ) * nquadRho + n );

            pressure << 8 << " " << i << " " << i + 1 << " " << n + 1 + s * shift << " " << n + s * shift << " "
                                 << i + shift << " " << i + 1 + shift << " " << n + 1 + shift + s * shift << " " << n + shift + s * shift << std::endl;
        }
    }
    
    // inner cylindrical core
    for( UInt s( 0 ); s != pdof - 1; ++s )
    {
        for( UInt v( 0 ); v != ( nquadTheta - 4 ) / 2 + 1; ++v )
        {
            UInt i( s * shift );
            pressure << 8 << " " << i << " " << i + ( 2 * v + 1 ) * nquadRho << " " << i + ( 2 * v + 2 ) * nquadRho << " " << i + ( 2 * v + 3 ) * nquadRho << " "
                                 << i + shift << " " << i + ( 2 * v + 1 ) * nquadRho + shift << " "
                                 << i + ( 2 * v + 2 ) * nquadRho + shift << " " << i + ( 2 * v + 3 ) * nquadRho + shift << std::endl;
        }
    }
      
    pressure << "CELL_TYPES " << ( pdof - 1 ) * ( ( nquadRho - 1 ) * nquadTheta + ( nquadTheta - 4 ) / 2 + 1 ) << std::endl;
    for( UInt h( 0 ); h != ( pdof - 1 ) * ( ( nquadRho - 1 ) * nquadTheta + ( nquadTheta - 4 ) / 2 + 1 ); ++h )
    {
        pressure << 12 << std::endl;
    }
    
			
			pressure << "POINT_DATA " << pdof * nquadRho * nquadTheta << std::endl;
			pressure << "SCALARS pressure double 1" << std::endl;
			pressure << "LOOKUP_TABLE default" << std::endl;
			
			for( UInt ix( 0 ); ix != pdof; ++ix )
			{     
				for( UInt itheta( 0 ); itheta != nquadTheta; ++itheta ) 
				{  
					for( UInt irho( 0 ); irho != nquadRho; ++irho )
					{
						pressure << solution_3D[ (3*udof + ix) * nquadTheta * nquadRho + itheta * nquadRho + irho ] << std::endl;
					}
				}
			}			
	
	pressure.close();
*/
}

} // end namespace
